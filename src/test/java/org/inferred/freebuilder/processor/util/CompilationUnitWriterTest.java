/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.inferred.freebuilder.processor.util;

import static com.google.common.collect.Iterables.getOnlyElement;
import static com.google.common.truth.Truth.assertThat;
import static javax.lang.model.util.ElementFilter.fieldsIn;
import static org.inferred.freebuilder.processor.util.SourceLevel.JAVA_6;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.concurrent.atomic.AtomicLong;

import javax.annotation.processing.Filer;
import javax.annotation.processing.FilerException;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.tools.JavaFileObject;

import org.inferred.freebuilder.processor.util.testing.ModelRule;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

/** Tests for {@link CompilationUnitWriter}. */
@RunWith(MockitoJUnitRunner.class)
public class CompilationUnitWriterTest {

  @Rule public final ModelRule model = new ModelRule();
  @Rule public final ExpectedException thrown = ExpectedException.none();
  @Mock private Filer filer;
  @Mock private JavaFileObject sourceFile;
  private final StringWriter source = new StringWriter();
  private TypeElement originatingElement;

  @Before
  public void setup() throws IOException {
    originatingElement = model.newType("package com.example; public class Foo { }");
    when(filer.createSourceFile((CharSequence) any(), (Element[]) any())).thenReturn(sourceFile);
    when(sourceFile.openWriter()).thenReturn(source);
  }

  @Test
  public void testConstructor() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      // Do nothing
    }
    assertEquals(
        "// Autogenerated code. Do not modify.\n"
            + "package com.example;\n\n",
        source.toString());
  }

  @Test
  public void testConstructor_avoidsEclipseWriterBug() throws IOException {
    // Due to a bug in Eclipse, we *must* call close on the object returned from openWriter().
    // Eclipse proxies a Writer but does not implement the fluent API correctly.
    // Here, we implement the fluent Writer API with the same bug:
    Writer mockWriter = Mockito.mock(Writer.class, new Answer<Object>() {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable {
        if (Writer.class.isAssignableFrom(invocation.getMethod().getReturnType())) {
          // Erroneously return the delegate writer (matching the Eclipse bug!)
          return source;
        } else {
          return Answers.RETURNS_SMART_NULLS.get().answer(invocation);
        }
      }});
    when(sourceFile.openWriter()).thenReturn(mockWriter);

    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      // Do nothing
    }
    verify(mockWriter).close();
  }

  @Test
  public void testAddLine() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter
          .addLine("public class Bar {")
          .addLine("  // %s %d", "Foo", 100)
          .addLine("}");
    }
    assertEquals(
        "// Autogenerated code. Do not modify.\n"
            + "package com.example;\n\n"
            + "public class Bar {\n"
            + "  // Foo 100\n"
            + "}\n",
        source.toString());
  }

  @Test
  public void testAddLine_typeInSamePackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be short: %s", originatingElement);
    }
    assertThat(source.toString()).contains("// This should be short: Foo\n");
  }

  @Test
  public void testAddLine_typeInJavaLangPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be short: %s", String.class);
    }
    assertThat(source.toString()).contains("// This should be short: String\n");
  }

  @Test
  public void testAddLine_primitiveType() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be short: %s", int.class);
    }
    assertThat(source.toString()).contains("// This should be short: int\n");
  }

  @Test
  public void testAddLine_typeInDifferentPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s", AtomicLong.class);
    }
    assertThat(source.toString()).contains("import java.util.concurrent.atomic.AtomicLong;\n");
    assertThat(source.toString()).contains("// This should be imported: AtomicLong\n");
  }

  @Test
  public void testAddLine_nestedTypeInDifferentPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s", ImmutableList.Builder.class);
    }
    assertThat(source.toString()).contains("import com.google.common.collect.ImmutableList;\n");
    assertThat(source.toString()).contains("// This should be imported: ImmutableList.Builder\n");
  }

  @Test
  public void testAddLine_typesWithSameName() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s", java.util.List.class);
      sourceWriter.addLine("// This should be explicit: %s", java.awt.List.class);
    }
    assertThat(source.toString()).contains("import java.util.List;\n");
    assertThat(source.toString()).doesNotContain("import java.awt.List;\n");
    assertThat(source.toString()).contains("// This should be imported: List\n");
    assertThat(source.toString()).contains("// This should be explicit: java.awt.List\n");
  }

  @Test
  public void testAddLine_typeMirrorInJavaLangPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be short: %s", model.typeMirror(String.class));
    }
    assertThat(source.toString()).contains("// This should be short: String\n");
  }

  @Test
  public void testAddLine_typeMirrorInDifferentPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s", model.typeMirror(AtomicLong.class));
    }
    assertThat(source.toString()).contains("import java.util.concurrent.atomic.AtomicLong;");
    assertThat(source.toString()).contains("// This should be imported: AtomicLong\n");
  }

  @Test
  public void testAddLine_genericTypeMirror() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s",
          model.typeMirror("java.util.List<java.lang.String>"));
    }
    assertThat(source.toString()).contains("import java.util.List;\n");
    assertThat(source.toString()).contains("// This should be imported: List<String>\n");
  }

  @Test
  public void testAddLine_typeElementInJavaLangPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be short: %s",
          model.typeUtils().asElement(model.typeMirror(String.class)));
    }
    assertThat(source.toString()).contains("// This should be short: String\n");
  }

  @Test
  public void testAddLine_typeElementInDifferentPackage() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s",
          model.typeUtils().asElement(model.typeMirror(AtomicLong.class)));
    }
    assertThat(source.toString()).contains("import java.util.concurrent.atomic.AtomicLong;\n");
    assertThat(source.toString()).contains("// This should be imported: AtomicLong\n");
  }

  @Test
  public void testAddLine_genericTypeElement() throws FilerException {
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      sourceWriter.addLine("// This should be imported: %s",
          model.typeUtils().asElement(model.typeMirror("java.util.List<java.lang.String>")));
    }
    assertThat(source.toString()).contains("import java.util.List;\n");
    // Turning a parameterized type mirror into an element loses the type parameters.
    assertThat(source.toString()).contains("// This should be imported: List\n");
  }

  @Test
  public void testAddLine_errorTypeArgument() throws FilerException {
    TypeElement myType = model.newType(
        "package com.example; class MyType {",
        "  java.util.List<NoSuchType<Foo>> foo;",
        "}");
    DeclaredType errorType = (DeclaredType)
        getOnlyElement(fieldsIn(myType.getEnclosedElements())).asType();
    assertEquals(TypeKind.ERROR, errorType.getTypeArguments().get(0).getKind());
    // Note: myType.toString() returns "java.util.List<<any>>" on current compilers. Weird.
    try (CompilationUnitWriter sourceWriter = newSourceWriter("com.example", "Bar")) {
      thrown.expect(IllegalArgumentException.class);
      sourceWriter.addLine("%s", errorType);
    }
  }

  private CompilationUnitWriter newSourceWriter(String pkg, String simpleName)
      throws FilerException {
    return new CompilationUnitWriter(
        filer,
        model.elementUtils(),
        JAVA_6,
        TypeReference.to(pkg, simpleName),
        ImmutableSet.<TypeReference>of(),
        originatingElement);
  }
}
